<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>JSound</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="generator" content="publican 3.2.1" /><meta name="package" content="JSound-JSound-0.1-en-US-1-4" /><meta name="description" content="This document is a description of the JSound, the JSON schema definition language. It describes how to declare constraints on the structure of JSON documents." /></head><body><p id="title"><a class="left" href="https://fedorahosted.org/publican"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="https://fedorahosted.org/publican"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><div class="book"><div class="titlepage"><div><div class="producttitle"><span class="productname">JSound</span> <span class="productnumber">0.1</span></div><div><h1 class="title"><a id="idm139773306026256"></a>JSound</h1></div><div><h2 class="subtitle">The complete reference</h2></div><p class="edition">Edition 0.1.4</p><div><h3 class="corpauthor">
		
	</h3></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Cezar</span> <span class="surname">Andrei</span></h3><code class="email"><a class="email" href="mailto:cezar.andrei@oracle.com">cezar.andrei@oracle.com</a></code></div><div class="author"><h3 class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></h3><code class="email"><a class="email" href="mailto:ghislain.fourny@28msec.com">ghislain.fourny@28msec.com</a></code></div><div class="author"><h3 class="author"><span class="firstname">Daniela</span> <span class="surname">Florescu</span></h3><code class="email"><a class="email" href="mailto:dana.florescu@oracle.com">dana.florescu@oracle.com</a></code></div><div class="editor"><h4 class="editedby">Edited by</h4><h3 class="editor"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></h3><div class="affiliation"><span class="orgname">28msec, Inc.</span></div><code class="email"><a class="email" href="mailto:ghislain.fourny@28msec.com">ghislain.fourny@28msec.com</a></code></div></div></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
			This document is a description of the JSound, the JSON schema definition language. It describes how to declare constraints on the structure of JSON documents.
		</div></div></div></div></div><div class="toc"><dl class="toc"><dt><span class="chapter"><a href="#chap-Introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773367264112">1.1. Requirements</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Concepts">2. Concepts</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773308258304">2.1. Candidate Instance</a></span></dt><dt><span class="section"><a href="#idm139773366360848">2.2. Annotated Instance</a></span></dt><dt><span class="section"><a href="#idm139773366383440">2.3. Schema Document</a></span></dt><dt><span class="section"><a href="#idm139773363357360">2.4. Meta Schema Document</a></span></dt><dt><span class="section"><a href="#idm139773309519552">2.5. Type</a></span></dt><dt><span class="section"><a href="#idm139773368495392">2.6. Base Type</a></span></dt><dt><span class="section"><a href="#idm139773368793792">2.7. Derived Type</a></span></dt><dt><span class="section"><a href="#idm139773373543664">2.8. Namespace</a></span></dt><dt><span class="section"><a href="#idm139773374129920">2.9. Qualified Name</a></span></dt><dt><span class="section"><a href="#idm139773324578112">2.10. Schema Document Soundness (aka Compilation)</a></span></dt><dt><span class="section"><a href="#idm139773323647888">2.11. Validation</a></span></dt><dt><span class="section"><a href="#idm139773323645904">2.12. Annotation</a></span></dt><dt><span class="section"><a href="#idm139773373369600">2.13. Meta Keys</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Schema">3. Schema Documents</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773310525968">3.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773322302032">3.2. Schema Document properties</a></span></dt><dt><span class="section"><a href="#idm139773322820752">3.3. Examples</a></span></dt><dt><span class="section"><a href="#idm139773327676368">3.4. Type Names and references to Types</a></span></dt><dt><span class="section"><a href="#idm139773327863248">3.5. Types</a></span></dt><dt><span class="section"><a href="#idm139773327857376">3.6. Derived Type properties</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Atomic">4. Atomic Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773311694592">4.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773361530656">4.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773370186992">4.3. Builtin Atomic Types</a></span></dt><dt><span class="section"><a href="#idm139773370527696">4.4. Atomic facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Object">5. Object Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773310071136">5.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773368752512">5.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773310137600">5.3. Builtin Object Type</a></span></dt><dt><span class="section"><a href="#idm139773371908224">5.4. Object Facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Array">6. Array Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773361522160">6.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773367722528">6.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773369650128">6.3. Builtin Array Type</a></span></dt><dt><span class="section"><a href="#idm139773329347952">6.4. Array facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-Union">7. Union Types</a></span></dt><dd><dl><dt><span class="section"><a href="#idm139773309944992">7.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773363549744">7.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773309805936">7.3. Union facets</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chap-SchemaSchema">8. Schema of Schemas</a></span></dt><dt><span class="appendix"><a href="#appe-JSound-Revision_History">A. Revision History</a></span></dt><dt><span class="index"><a href="#idm139773372063072">Index</a></span></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Introduction"></a>Chapter 1. Introduction</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773367264112">1.1. Requirements</a></span></dt></dl></div><div class="para">
		Over the past decade, the need for more flexible and scalable databases has greatly increased. The NoSQL universe brings many new ideas on how to build both scalable data storage and scalable computing infrastructures.
	</div><div class="para">
		XML and <a href="http://www.json.org/">JSON</a> are probably the most popular two data formats that emerged. While XML reached a level of maturity that gives it an enterprise-ready status, JSON databases are still in their early stages. Scalable data stores (like <a href="http://www.mongodb.org/">MongoDB</a>) are already available. <a href="http://www.jsoniq.org/">JSONiq</a> brings SQL-like query capabilities to JSON. The last missing piece for a full-fledged JSON database is a way to make sure that the data stored is consistent and sound. This is where schemas come into play.
	</div><div class="para">
		Many lessons can be learned from 40 years of relational databases history and 15 years of XML. The goal of this document is to introduce a schema language, JSound, which is much simpler than XML Schema, just like JSON syntax is much simpler than XML syntax.
	</div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773367264112"></a>1.1. Requirements</h2></div></div></div><div class="para">
			The JSound schema definition language is based on the following requirements:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					A schema document must be a well-formed JSON document in the sense that it parses against the JSON grammar.
				</div></li><li class="listitem"><div class="para">
					A schema document must be valid in the sense that there is a JSound metaschema document against which all schema documents (including itself) are valid.
				</div></li><li class="listitem"><div class="para">
					While the schema definition language is greatly inspired from XML Schema, it must avoid its complexity. It must be simpler and more readable.
				</div></li><li class="listitem"><div class="para">
					JSound must support most of the <a href="http://www.w3.org/TR/xmlschema11-2/#built-in-datatypes">XML Schema primitive atomic types</a>, as many of them are very useful and completely orthogonal to XML.
				</div></li><li class="listitem"><div class="para">
					JSound must avoid the XML Schema model of restriction/extension of structured types. Instead, it must support a different model of subtyping based on classical object-oriented inheritance. In JSound, a subtype's value space must always be a subset of its base type's value space.
				</div></li><li class="listitem"><div class="para">
					It must be possible to mark string/value pairs in an object type as optional or to specify a default value in case of absence.
				</div></li><li class="listitem"><div class="para">
					It should be possible, given a JSON document, to turn it into a schema against which it is valid with minimal changes.
				</div></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Concepts"></a>Chapter 2. Concepts</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773308258304">2.1. Candidate Instance</a></span></dt><dt><span class="section"><a href="#idm139773366360848">2.2. Annotated Instance</a></span></dt><dt><span class="section"><a href="#idm139773366383440">2.3. Schema Document</a></span></dt><dt><span class="section"><a href="#idm139773363357360">2.4. Meta Schema Document</a></span></dt><dt><span class="section"><a href="#idm139773309519552">2.5. Type</a></span></dt><dt><span class="section"><a href="#idm139773368495392">2.6. Base Type</a></span></dt><dt><span class="section"><a href="#idm139773368793792">2.7. Derived Type</a></span></dt><dt><span class="section"><a href="#idm139773373543664">2.8. Namespace</a></span></dt><dt><span class="section"><a href="#idm139773374129920">2.9. Qualified Name</a></span></dt><dt><span class="section"><a href="#idm139773324578112">2.10. Schema Document Soundness (aka Compilation)</a></span></dt><dt><span class="section"><a href="#idm139773323647888">2.11. Validation</a></span></dt><dt><span class="section"><a href="#idm139773323645904">2.12. Annotation</a></span></dt><dt><span class="section"><a href="#idm139773373369600">2.13. Meta Keys</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773308258304"></a>2.1. Candidate Instance</h2></div></div></div><div class="para">
			This is a JDM (JSONiq Data Model) value. A Candidate Instance may or not be valid against a Schema Type.
		</div><div class="para">
			In the JSONiq Data Model, instances can be objects, arrays, or atomics.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					An object has an unordered list of string/value pairs. A top-level object is also referred to as a "JSON document".
				</div></li><li class="listitem"><div class="para">
					An array has an ordered list of values.
				</div></li><li class="listitem"><div class="para">
					An atomic has a value annotated with an atomic type.
				</div></li></ul></div><div class="para">
			Typically, the Candidate Instance will have been freshly parsed and will only have atomics of type string, integer, decimal, double, boolean and null. Integer, decimal and double values correspond to parsed JSON numbers, depending on the presence of dots and scientific notation.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773366360848"></a>2.2. Annotated Instance</h2></div></div></div><div class="para">
			An Annotated Instance is a "Post-validation JDM Instance", i.e., it corresponds to a Candidate Instance that has been recursively annotated after going through the Annotation process against a Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773366383440"></a>2.3. Schema Document</h2></div></div></div><div class="para">
			A Schema Document is a JSON document which defines Types against which Candidate Instances are being validated. A Schema Document is also a Candidate Instance and must be valid against the Meta Schema Type. A Schema Document must also fulfill additional consistency constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773363357360"></a>2.4. Meta Schema Document</h2></div></div></div><div class="para">
			A Meta Schema Document is a JSON document that defines the Type against which all Schema Documents are valid including itself.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773309519552"></a>2.5. Type</h2></div></div></div><div class="para">
			A Schema Document defines Types, which may or may not be anonymous. A Candidate Instance may or may not be valid against a Type. A Candidate Instance can be annotated against a Type, which results in an Annotated Instance. There are four kinds of Types: Atomic, Array, Object and Union. Types are represented with objects that are nested in a Schema Document. Named Types can also be referred to with Qualified Names.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773368495392"></a>2.6. Base Type</h2></div></div></div><div class="para">
			JSound Types are organized in a Subtype hierarchy. There is a number of builtin Types, and a Schema Document can define new Derived Types that restricts the value space of their Base Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773368793792"></a>2.7. Derived Type</h2></div></div></div><div class="para">
			JSound's type hierarchy is very strict about value spaces. The value space of a Derived Type is always a subset of the value space of its Base Type. To restrict its Base Type's value space, a Derived Type can provide new Facets, or make existing Facets more restrictive.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773373543664"></a>2.8. Namespace</h2></div></div></div><div class="para">
			A JSound Schema Document is associated with a Namespace, and all types that it defines live in that Namespace. However, Namespaces in JSound are much closer to C++ namespaces or Java packages than to XML namespaces. Prefixes may still, but must not be, used as convenient shorcuts to avoid writing long URIs.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773374129920"></a>2.9. Qualified Name</h2></div></div></div><div class="para">
			Type names are Qualified Names, which are made of a namespace and of a local name. Local names must be unique in a namespace, but not across namespaces -- like in C++ or Java. Qualified Names have the following string representation: "Q{&lt;namespace&gt;}&lt;local name&gt;". For example: "Q{http://www.example.com/types}small-integer"
		</div><div class="para">
			For convenience, Namespaces that are imported can be bound to prefixes in the containing Schema Document, and the prefix can be used as a shortcut to the full namespace like so: "&lt;prefix&gt;:&lt;local name&gt;". If the prefix "my" is bound to the Namespace "http://www.example.com/types" in the Schema Document, the above example can also be represented as "my:small-integer".
		</div><div class="para">
			Builtin Type names are special in that they are in no Namespace and can also be represented with no prefix : "integer".
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773324578112"></a>2.10. Schema Document Soundness (aka Compilation)</h2></div></div></div><div class="para">
			When a Schema Document is provided, it must be checked for consistency. For example, a Type may not override its Base Type's Facets in a less restrictive way. If an inconsistency is discovered in a Schema Document, a static error is raised.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773323647888"></a>2.11. Validation</h2></div></div></div><div class="para">
			A Candidate Instance can be validated against a Type. The Validation action takes a Candidate Instance and a Type (typically, a set of Schema Documents and the name of a Type defined in one of them). It results in a boolean that describes whether the Candidate Instance is valid against the Type given its definition in the set of Schema Documents. If the Candidate Instance is not valid (false is returned), no error is raised but the Annotation phase can be used to obtain a copy of the Candidate Instance annotated with the validation errors.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773323645904"></a>2.12. Annotation</h2></div></div></div><div class="para">
			Annotation is the action of passing a Candidate Instance through a Schema Type (identified with a name in a set of of Schema Documents) and recursively:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					annotating an object or an array with the current Schema Type as well as determining against which Schema Type the object pair values or array members will be annotated.
				</div><div class="para">
					casting an atomic to the current Schema Type.
				</div></li></ul></div><div class="para">
			Note that this action is independent of Validation: The two actions can be performed in tandem but they are not required. As the Validation action, the Annotation action takes a Candidate Instance, a Type (typically, a set of Schema Documents and the name of a Type defined in one of them) and results in a set of annotations on the Instance that describe the Types which the nested Instances match. This action also works on Instances that validate partially. When a Type cannot be found that matches a given nested Candidate Instance, a special annotation is used.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773373369600"></a>2.13. Meta Keys</h2></div></div></div><div class="para">
			Schema Documents mix keys that are describing actual data fields (actual keys) and keys that define the Types (meta keys). To make the distinction between the two, we use the $ (dollar sign) to represent the meta keys. In order to use $ in actual keys one should use the escaped version by doubling the $ character. This is consistent with other JSON meta languages.
		</div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Schema"></a>Chapter 3. Schema Documents</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773310525968">3.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773322302032">3.2. Schema Document properties</a></span></dt><dt><span class="section"><a href="#idm139773322820752">3.3. Examples</a></span></dt><dt><span class="section"><a href="#idm139773327676368">3.4. Type Names and references to Types</a></span></dt><dt><span class="section"><a href="#idm139773327863248">3.5. Types</a></span></dt><dt><span class="section"><a href="#idm139773327857376">3.6. Derived Type properties</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773310525968"></a>3.1. Scope</h2></div></div></div><div class="para">
			Schema Documents have a namespace and define multiple Types in this namespace.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773322302032"></a>3.2. Schema Document properties</h2></div></div></div><div class="para">
			Schema Documents are (serialized) JSON objects which have the following properties
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$namespace (JSON string): the namespace (URI) in which the types defined in this Schema Document live. This property is required and a static error <code class="code">jsd:JDST0001</code> is raised if it is missing.
				</div></li><li class="listitem"><div class="para">
					$about (JSON value): free content (documentation, comments, ...).
				</div></li><li class="listitem"><div class="para">
					$imports (JSON array of objects) : used to import Types located in other Schema Documents (i.e., in other Namespaces). Imports are not recursive, i.e., importing a Schema Document does not import the further Schema Documents that it may itself import.
				</div><div class="para">
					Each JSON object in this JSON array has the following properties:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							$namespace (JSON string): the namespace in which the Types being imported live.
						</div></li><li class="listitem"><div class="para">
							$location (JSON string): a hint about where to find the Schema Document for this namespace.
						</div></li><li class="listitem"><div class="para">
							$prefix (JSON string): the prefix used in Qualified Names to refer to Types in the above namespace. Must not contain a colon, otherwise <code class="code">jsd:JDST0004</code> is raised.
						</div></li></ul></div><div class="para">
					If $namespace or $prefix is missing in any of these objects, a static error <code class="code">jsd:JDST0001</code> is raised.
				</div><div class="para">
					If two objects are provided with the same $prefix, a static error <code class="code">jsd:JDST0006</code> is raised.
				</div></li><li class="listitem"><div class="para">
					$types (JSON array of objects representing Types) : the Types defined in this document. How these objects look like is explained in subsequent sections.
				</div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773322820752"></a>3.3. Examples</h2></div></div></div><div class="para">
			This Schema Document defines two Atomic Types in the "http://www.example.com/my-schema" namespace and with the local names "small-number" and "big-number".
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "atomic",
      "$name" : "small-number",
      "$baseType" : "integer",
      "$enumeration" : [ 1, 2, 4, 8 ]
    },
    {
      "$kind" : "atomic",
      "$name" : "Q{http://www.example.com/my-schema}big-number",
      "$baseType" : "integer",
      "$enumeration" : [ 1000, 2000, 4000, 8000 ]
    }
  ]
}
</pre><div class="para">
			This Schema Document defines one Object Type in the "http://www.example.com/my-new-schema" namespace named "small-and-big".
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-new-schema",
  "$imports" : [
    {
      "$namespace" : "http://www.example.com/my-schema",
      "$prefix" : "other"
    }
  ],
  "$types" : [
    {
      "$kind" : "object",
      "$name" : "small-and-big",
      "$content" : {
        "small" : { "$type" : "other:small-number" },
        "big" : { "$type" : "other:big-number", "$optional" : true }
      }
    }
  ]
}
</pre><div class="para">
			Given this set of two Schema Documents, the following JSON object:
		</div><pre class="programlisting">
{
  "small" : 4
}
</pre><div class="para">
			is valid against the Type named "Q{http://www.example.com/my-new-schema}small-and-big".
		</div><div class="para">
			This JSON object is not valid, because the value associated with "big" is not in the value space of the Type "Q{http://www.example.com/my-schema}big-number".
		</div><pre class="programlisting">
{
  "small" : 4,
  "big" : 3
}
</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773327676368"></a>3.4. Type Names and references to Types</h2></div></div></div><div class="para">
			Type Names are Qualified Names, made of a namespace and of a local name, as described in the former chapter.
		</div><div class="para">
			Types names are used to (optionally) name Types, or to refer to another Type as a base type.
		</div><div class="para">
			References to Types that are defined in the same Schema Document can be referred to with no prefix as well: the namespace is that of the defining Schema Document. If there is a collision with Builtin Type names, the locally defined Type has precedence (the Builtin Type is hidden).
		</div><div class="para">
			Whenever a Qualified cannot be resolved (either because if an unbound prefix, or because no Type with this Qualified name is found), a static error <code class="code">jsd:JDST0002</code> is raised.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773327863248"></a>3.5. Types</h2></div></div></div><div class="para">
			There are four kinds of Types: atomic, object, array and union.
		</div><div class="para">
			Types are either Builtin, in which case their name is in no namespace, or Derived.
		</div><div class="para">
			The topmost Type is builtin and is named "item".
		</div><div class="para">
			The topmost Object Type is builtin and is named "object".
		</div><div class="para">
			The topmost Array Type is builtin and is named "array".
		</div><div class="para">
			The topmost Atomic Type is builtin and is named "atomic". There are many further Builtin Atomic Types.
		</div><div class="para">
			Derived Types are always defined by restricting the value space of a <span class="emphasis"><em>base type</em></span> by means of <span class="emphasis"><em>facets</em></span>. They have a JSON object representation.
		</div><div class="para">
			Derived Object Types may be derived from any other Object Type. Derived Array Types may be derived from any other Array Type. Derived Union Types are always directly derived from "item". Derived Atomic Types may be derived from any other Atomic Type.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773327857376"></a>3.6. Derived Type properties</h2></div></div></div><div class="para">
			A Derived Type has the following properties:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$kind (JSON string): the kind of the Type. One of "atomic, "object", "array", "union".
				</div></li><li class="listitem"><div class="para">
					$name (JSON string): a string containing the Qualified Name (as defined above) of this Type.
				</div></li><li class="listitem"><div class="para">
					$baseType (JSON string): a string containing the Qualified Name of the Type which is the base type of this Type.
				</div></li><li class="listitem"><div class="para">
					$about (JSON value): free content (documentation, comments, ...).
				</div></li><li class="listitem"><div class="para">
					various facets properties. Which facets are available defines on the $kind of the Type.
				</div></li></ul></div><div class="para">
			There are the following constraints on these properties:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					An error <code class="code">jsd:JDST0001</code> is raised if $kind is missing.
				</div></li><li class="listitem"><div class="para">
					An error <code class="code">jsd:JDST0003</code> is raised if any other value is encountered for $kind.
				</div></li><li class="listitem"><div class="para">
					$name, if present, must live in the namespace of the Schema Document in which this Type is defined. Otherwise, <code class="code">jsd:JDST0005</code> is raised.
				</div></li><li class="listitem"><div class="para">
					Types defined directly in the top-level $types array must be named. Otherwise, an error <code class="code">jsd:JDST0001</code> is raised.
				</div></li><li class="listitem"><div class="para">
					$baseType must refer to a known Type - builtin, in the same Schema Document or in an imported Schema Document. In particular, if a prefix is used, it must be bound to an imported namespace. Otherwise, a static error <code class="code">jsd:JDST0002</code> is raised.
				</div></li><li class="listitem"><div class="para">
					If $kind is "object", $baseType must be "object" if provided.
				</div></li><li class="listitem"><div class="para">
					If $kind is "array", $baseType must be "array" if provided.
				</div></li><li class="listitem"><div class="para">
					If $kind is "union", $baseType must be "item" if provided.
				</div></li><li class="listitem"><div class="para">
					If $kind is "atomic", $baseType must be the Qualified Name of an existing Atomic Type.
				</div></li></ul></div><div class="para">
			If $kind and $baseType are not consistent as specified above, a static error <code class="code">jsd:JDST0007</code> is raised.
		</div><div class="para">
			Here is an example of an invalid Schema Document, because it does not fulfill many of the above constraints.
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "atomic",
      "$name" : "type1",
      "$baseType" : "unbound:type", (: prefix is not bound :)
      "$maxInclusive" : 4
    },
    {
      "$kind" : "atomic",
      "$name" : "Q{http://www.example.com/other}type2", (: the namespace must match that of the Schema document :)
      "$baseType" : "integer",
      "$maxInclusive" : 4
    },
    {
      "$kind" : "atomic",
      "$name" : "Q{http://www.example.com/my-schema}type3",
      "$baseType" : "object", (: base type MUST also be an atomic type :)
      "$maxInclusive" : 4
    },
    {
      "$kind" : "object",
      "$name" : "object1",
      "$baseType" : "type1" (: base type MUST be "object":)
      "$content" : {}
    },
    {
      "$kind" : "object",
      "$name" : "object2",
      "$baseType" : "object1" (: base type MUST be "object":)
    }
  ]
}
</pre><div class="para">
			If a Derived Type inherits its Base Type's Facets. It can set a new Facet if its Base Type does not already have it, or it can redefine a Facet. However, a Facet can only be redefined if its new value is more restrictive that in its Base Type, otherwise, a static error <code class="code">jsd:JDST0007</code> is raised.
		</div><div class="para">
			Some Facets, like $constraints or $pattern, are Accumulative Facets. This means that redefining them is done by adding new constraints or patterns to the already present ones, without raising <code class="code">jsd:JDST0007</code>.
		</div><div class="para">
			There are two facets common to all types:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$enumeration (array of JSON values): Constrains a value space to a specified set of values.
				</div></li><li class="listitem"><div class="para">
					$constraints (array of JSON strings): Constrains a value space to the values for which a set of JSONiq queries evaluates to true. In these JSONiq queries, the context item is bound to the Serialized Instance being validated, after parsing. This facet is accumulated, i.e., if a Derived Type redefines it, the new JSONiq queries are added to the set, making it more restrictive. The JSONiq query potentially raises static and dynamic errors as defined in JSONiq.
				</div></li></ul></div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "object"
      (: "$baseType" : "object" is implicit :)
      "$name" : "two-objects",
      "$enumeration" : [ { "foo" : "bar" }, {} ] (: only these two objects :)
    },
    {
      "$kind" : "array"
      (: "$baseType" : "array" is implicit :)
      "$name" : "uniform-array",
      "$constraints" : [ "every $i in 1 to size($$) satisfies deep-equals($$($i), $$(1))" ]  (: all members must be the same :)
    },
  ]
}
</pre><div class="para">
			The following JSON object is valid against Q{http://www.example.com/my-schema}two-objects.
		</div><pre class="programlisting">
{ "foo" : "bar" }
</pre><div class="para">
			The following JSON array is valid against Q{http://www.example.com/my-schema}uniform-array.
		</div><pre class="programlisting">
[ 42, 42, 42 ]
</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Atomic"></a>Chapter 4. Atomic Types</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773311694592">4.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773361530656">4.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773370186992">4.3. Builtin Atomic Types</a></span></dt><dt><span class="section"><a href="#idm139773370527696">4.4. Atomic facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773311694592"></a>4.1. Scope</h2></div></div></div><div class="para">
			Atomic Types match atomics (JSON leaf values: strings, numbers, booleans, nulls).
		</div><div class="para">
			Atomic Types have a lexical space (a set of literals denoting the values), a value space (a set of actual values), and a lexical mapping which maps the former into the latter.
		</div><div class="para">
			An Atomic Type can be either the topmost <span class="emphasis"><em>atomic</em></span>, or a <span class="emphasis"><em>primitive</em></span> builtin type, or a builtin type <span class="emphasis"><em>derived</em></span> from a primitive type, or a user-defined type <span class="emphasis"><em>derived</em></span> from any other Atomic Type (except <span class="emphasis"><em>atomic</em></span>).
		</div><div class="para">
			A Derived Atomic Type can be defined by restricting the value space of another Atomic Type by specifying atomic facets. A restriction can also be made with the general facets $enumeration and $constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773361530656"></a>4.2. Examples</h2></div></div></div><div class="para">
			Given the following Schema Document:
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "atomic",
      "$name" : "foo-and-bar",
      "$baseType" : "string",
      "$enumeration" : [ "foo", "bar" ]
    },
    {
      "$kind" : "atomic",
      "$name" : "digits",
      "$baseType" : "integer",
      "$minInclusive" : 1,
      "$maxExclusive" : 10
    },
    {
      "$kind" : "atomic",
      "$name" : "few-digits",
      "$baseType" : "my:digits",
      "$enumeration" : [ 4, 6 ]
    }
  ]
}
</pre><div class="para">
			The strings "foo" and "bar" are valid against Type named "Q{http://www.example.com/my-schema}foo-and-bar". The string "foobar" and the array [ "foo", "bar" ] are not.
		</div><div class="para">
			The atomics (integers) 2 and 7 are valid against the Type named "Q{http://www.example.com/my-schema}digits". The string "2", the integer 0 and the array [ "foo", "bar" ] are not.
		</div><div class="para">
			The integer 4 is valid against the Type named "Q{http://www.example.com/my-schema}few-digits". The integer 2, the integer 0 and the array [ "foo", "bar" ] are not.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773370186992"></a>4.3. Builtin Atomic Types</h2></div></div></div><div class="para">
			A number of builtin Atomic Types are predefined. Most of them have counterparts in XML Schema 1.1, because they are very useful also in JSON (for example : dates, times, ...). In particular, they have the same value space, the same lexical space, the same lexical mapping and (for primitive types) the same associated set of atomic facets.
		</div><div class="para">
			Some of these builtin types are primitive and marked as such below. Others are derived from another builtin type.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#string">string</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#anyURI">anyURI</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#base64Binary">base64Binary</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#hexBinary">hexBinary</a> (primitive).
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#date">date</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#dateTime">dateTime</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#time">time</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">dateTimeStamp</a> (derived from dateTime),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gYear">gYear</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gYearMonth">gYearMonth</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gMonth">gMonth</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gMonthDay">gMonthDay</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#gDay">gDay</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#duration">duration</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#dayTimeDuration">dayTimeDuration</a> (derived from duration),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#yearMonthDuration">yearMonthDuration</a> (derived from duration),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#decimal">decimal</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#integer">integer</a> (derived from decimal),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#long">long</a> (derived from integer),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#int">int</a> (derived from long),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#short">short</a> (derived from int),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#byte">byte</a> (derived from short),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#double">double</a> (primitive),
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#float">float</a> (primitive).
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#boolean">boolean</a> (primitive)
				</div></li><li class="listitem"><div class="para">
					null (primitive), which has a singleton value space containing the JSON null value with the lexical representation "null".
				</div></li></ul></div><div class="para">
			There is also a special builtin type <span class="emphasis"><em>atomic</em></span>, which is a supertype of all primitive types and, by transition, of all atomic types.
		</div><div class="para">
			The lexical namespace of dateTime as defined in XML Schema 1.1 is a superset of the date representation defined in <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">ECMAScript</a>. In addition, JSound extends the lexical representation of respectively date, time, dateTime defined above, to allow the format defined in <a href="http://tools.ietf.org/html/rfc2822#page-14">RFC 2822</a> (nonterminals date, time, date-time respectively). This is because many JavaScript implementations do so.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773370527696"></a>4.4. Atomic facets</h2></div></div></div><div class="para">
			Restriction is done using the general facets, or the following atomic facets (they must be available for the base type).
		</div><div class="para">
			These facets are defined in XML Schema 1.1. For convenience, the summary from the XML Schema 1.1 specification is provided below. Which primitive type has which facets is defined in XML Schema 1.1 as well.
		</div><div class="para">
			The following atomic facets are available for the primitive types string, anyURI, base64Binary, hexBinary:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-length">$length</a> (integer): Constraining a value space to values with a specific number of units of length, where units of length varies depending on the base type.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-minLength">$minLength</a> (integer): Constraining a value space to values with at least a specific number of units of length, where units of length varies depending on the base type.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-maxLength">$maxLength</a> (integer): Constraining a value space to values with at most a specific number of units of length, where units of length varies depending on the base type.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for the primitive types date, dateTime, time, gYear, gYearMonth, gMonth, gMonthDay, gDay, duration, decimal, double, float:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-maxInclusive">$maxInclusive</a> (atomic): Constraining a value space to values with a specific inclusive upper bound.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-maxExclusive">$maxExclusive</a> (atomic): Constraining a value space to values with a specific exclusive upper bound.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-minExclusive">$minExclusive</a> (atomic): Constraining a value space to values with a specific exclusive lower bound.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-minInclusive">$minInclusive</a> (atomic): Constraining a value space to values with a specific inclusive lower bound.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for the primitive type decimal:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-totalDigits">$totalDigits</a> (integer): Restricting the magnitude and arithmetic precision of values in the value spaces of decimal and datatypes derived from it.
				</div></li><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-fractionDigits">$fractionDigits</a> (integer): Placing an upper limit on the arithmetic precision of decimal values.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for the primitive types date, dateTime, time:
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-explicitTimezone">$explicitTimezone</a> ("required", "prohibited" or "optional"): Requiring or prohibiting the time zone offset in date/time datatypes.
				</div></li></ul></div><div class="para">
			The following atomic facets are available for all primitive types (including boolean and null):
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					<a href="http://www.w3.org/TR/xmlschema11-2/#rf-pattern">$pattern</a> (string): Constraining a value space to values that are denoted by literals which match each of a set of regular expressions.
				</div></li></ul></div><div class="para">
			Of the above Facets, only $pattern is an Accumulative Facet. The others raise <code class="code">jsd:JDST0007</code> if redefined in a less restrictive way.
		</div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Object"></a>Chapter 5. Object Types</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773310071136">5.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773368752512">5.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773310137600">5.3. Builtin Object Type</a></span></dt><dt><span class="section"><a href="#idm139773371908224">5.4. Object Facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773310071136"></a>5.1. Scope</h2></div></div></div><div class="para">
			Object Types match objects.
		</div><div class="para">
			There is one builtin Object Type: "object" which is the direct base type of all other Object Types.
		</div><div class="para">
			An Object Type can be defined by restricting the value space of "object" by specifying a layout (type of the pairs, optional or not, ...). A restriction can also be made with the general Types facets $enumeration and $constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773368752512"></a>5.2. Examples</h2></div></div></div><div class="para">
			Against the following Object Type:
		</div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
     "$kind" : "object",
     "$content" : {
       "foo" : {
         "$type" : "string",
       }
     },
     "$open" : false,
     "$name" : "only-foo"
    },
    {
      "$kind" : "object",
      "$content" : {
        "foo" : {
          "$type" : "string",
        },
        "bar" : {
         "$type" : "boolean",
         "$optional" : true
       }
     }
    "$name" : "foo-bar-and-arrays"
    }
  ]
}
</pre><div class="para">
			The objects { "foo" : "bar" } and { "foo" : "foo" } are valid against the Type named "Q{http://www.example.com/my-schema}only-foo" because the foo pairs are strings.
		</div><div class="para">
			The object {} is not because the foo pair is missing.
		</div><div class="para">
			The object { "foo" : "bar", "bar" : "foo" } is not because no other pair than "foo" is allowed (closed Object Type).
		</div><div class="para">
			Against the Type named "Q{http://www.example.com/my-schema}only-foo":
		</div><div class="para">
			The objects { "foo" : "bar", "foobar" : [ "foo" ] } and { "foo" : "bar", "bar" : true } are valid because the foo pairs are strings, bar is optional and the Object Type is $open.
		</div><div class="para">
			The objects {} and { "bar" : "foo" } and { "foo" : "bar", "bar" : "foo" } are not because the foo pair is missing or the bar pair is not a boolean.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773310137600"></a>5.3. Builtin Object Type</h2></div></div></div><div class="para">
			There is one topmost, builtin Object Type named <span class="emphasis"><em>object</em></span>, against which all objects are valid.
		</div><div class="para">
			This topmost type can be seen as having its $content Facet as the empty object, and its $open Facet as true.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773371908224"></a>5.4. Object Facets</h2></div></div></div><div class="para">
			Restriction is done using the general Facets, or the following object Facets.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$content (object): the layout definition. Each pair in $content is called a field descriptor. The value in each field descriptor has the following properties.
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							$type (string or object) - required (<code class="code">jsd:JDST0001</code> if absent): the name of a Type (Qualified Name in a string) or the type itself (an object) that the value must match. <code class="code">jsd:JDST0002</code> is raised if if is a Qualified Name that cannot be resolved.
						</div></li><li class="listitem"><div class="para">
							$optional (boolean) - optional: indicates that the pair is optional. Default is false.
						</div></li><li class="listitem"><div class="para">
							$default (item) - optional: indicates a default value to be taken the value is missing in the Serialized Instance. $optional is then ignored.
						</div><div class="para">
							However, if this value is an object with a pair named $computed (which must be associated with a string), then the JSONiq query in $content.$default.$computed is executed upon Annotation, with the context item bound to the Candidate Instance being matched against the containing Object Type. It must result in one item, which is the default value for the Pair Descriptor.
						</div></li></ul></div><div class="para">
					An object $o is valid against the $content facet if the following conditions are met:
				</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
							For each pair $k : $v in the field descriptor such that $v."$optional" is false and $v."$default" is absent, there must be a pair named $k in $o.
						</div></li><li class="listitem"><div class="para">
							For each pair $k : $v in the field descriptor, if $o.$k exists, then $o.$k must be valid against the Type $v."$type".
						</div></li></ul></div></li><li class="listitem"><div class="para">
					$open (boolean) : specifies whether pairs not specified in $content are to be accepted. The default is the same as the $baseType (true if $baseType is object).
				</div><div class="para">
					All objects are valid against the $open facet if it is set to true.
				</div><div class="para">
					If it is set to false, an object $o is valid against the $open facet if all its keys appear in $content, or in the $content of a super type.
				</div></li></ul></div><div class="para">
			The $open Facet behaves like most Facets, i.e., if that of the Base Type is false, it cannot be set back to true, otherwise <code class="code">jsd:JDST0007</code> is raised.
		</div><div class="para">
			The $content Facet is Accumulative, in that the new field descriptors are actually merged with the Base Type's $content Facet.
		</div><div class="para">
			If a field descriptor in the $content Facet is overriden, it must be more restrictive, i.e., its $type must be a subtype of the $type associated to this key by the closest super type which does so. Also, $optional, if false, cannot be set back to true. If any of these two constraints is not met, <code class="code">jsd:JDST0007</code> is raised.
		</div><div class="para">
			Finally, there is an additional constraint that spans across the two object Facets: Field descriptors with new keys may not be added to the $content Facet if the $baseType's $open Facet is false. Otherwise, <code class="code">jsd:JDST0008</code> is raised.
		</div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Array"></a>Chapter 6. Array Types</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773361522160">6.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773367722528">6.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773369650128">6.3. Builtin Array Type</a></span></dt><dt><span class="section"><a href="#idm139773329347952">6.4. Array facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773361522160"></a>6.1. Scope</h2></div></div></div><div class="para">
			Array Types match arrays.
		</div><div class="para">
			There is one builtin topmost Array Type "array".
		</div><div class="para">
			An Array Type can be defined by restricting the value space of an array Base Type by specifying a layout (type of the members) or size bounds. A restriction can also be made with the general Types facets $enumeration and $constraints.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773367722528"></a>6.2. Examples</h2></div></div></div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
      "$kind" : "array",
      "$content" : [ "string" ],
      "$name" : "strings"
    },
    {
      "$kind" : "array",
      "$content" : [ "string" ],
      "$maxLength" : 5,
      "$name" : "less-than-five-members"
    },
    {
      "$kind" : "array",
      "$content" : [ "integer" ],
      "$constraints" : [ "every $i in $$ satisfies $i le 10" ],
      "$name" : "all-less-than-ten"
    }
  ]
}</pre><div class="para">
			[ "foo " "bar" ] is valid against the Type named "Q{http://www.example.com/my-schema}strings" but not [ 1, 2, "foo" ].
		</div><div class="literallayout"><p><br />
</p></div><div class="para">
			[ "foo " "bar" ] is valid against the Type named "Q{http://www.example.com/my-schema}less-than-five-members" but not [ "foo", "foo", "foo", "foo", "foo", "foo" ].
		</div><div class="literallayout"><p><br />
</p></div><div class="para">
			[ 1, 3, 5 ] is valid against the Type named "Q{http://www.example.com/my-schema}all-less-than-ten" but not [ 1, 3, 72 ].
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773369650128"></a>6.3. Builtin Array Type</h2></div></div></div><div class="para">
			There is one topmost, builtin Array Type named <span class="emphasis"><em>array</em></span>, against which all arrays are valid.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773329347952"></a>6.4. Array facets</h2></div></div></div><div class="para">
			Restriction is done using the general facets, or the following array facets.
		</div><div class="para">
			JSound supports the following array facets.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$content (singleton array of one string or object) : the name of a Type (Qualified Name in a string) or the type itself (an object) that all members must match.
				</div></li><li class="listitem"><div class="para">
					$minLength (integer) : the minimum length.
				</div></li><li class="listitem"><div class="para">
					$maxLength (integer) : the maximum length.
				</div></li></ul></div><div class="para">
			The above three facets behave like normal Facets, i.e., <code class="code">jsd:JDST0007</code> is raised if they are already defined by their Base Type, and redefined by the Derived Type in a less restrictive way.
		</div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-Union"></a>Chapter 7. Union Types</h1></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="#idm139773309944992">7.1. Scope</a></span></dt><dt><span class="section"><a href="#idm139773363549744">7.2. Examples</a></span></dt><dt><span class="section"><a href="#idm139773309805936">7.3. Union facets</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773309944992"></a>7.1. Scope</h2></div></div></div><div class="para">
			The value space of a Union Type is the union of the value spaces of all its member types.
		</div><div class="para">
			There is no Builtin Union Type. All Union Types have directly the topmost "item" as their base type and restrict the value space by specifying the $content facet. General facets can also be used.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773363549744"></a>7.2. Examples</h2></div></div></div><pre class="programlisting">
{
  "$namespace" : "http://www.example.com/my-schema",
  "$types" : [
    {
    "$kind" : "union",
    "$content" : [ "string", { "$kind" : "array", "$content" : [ "integer" ] } ],
    "$name" : "string-or-integer-array"
    },
    {
    "$kind" : "union",
    "$content" : [ "string", { "$kind" : "array", "$content" : [ "integer" ] } ],
    "$enumeration" : [ "foo", [ 1, 2, 3, 4 ] ], 
    "$name" : "just-two"
    }
  ]
}
</pre><div class="para">
			"foo", "bar" and [ 1, 2, 3 ] are valid against the Type named "Q{http://www.example.com/my-schema}string-or-integer-array" but 3.14 and true are not.
		</div><div class="para">
			"foo", and [ 1, 2, 3, 4 ] are valid against the Type named "Q{http://www.example.com/my-schema}just-two" but [ 1 ] and "bar" are not.
		</div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="idm139773309805936"></a>7.3. Union facets</h2></div></div></div><div class="para">
			The specification of member types is done using one (compulsory) union facet, and optionally general facets.
		</div><div class="itemizedlist"><ul><li class="listitem"><div class="para">
					$content (array of (string or object) ) : each member in the array is the name of a Type (Qualified Name in a string) or the member type itself (an object).
				</div></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="chap-SchemaSchema"></a>Chapter 8. Schema of Schemas</h1></div></div></div><pre class="programlisting"> 
{
  "$namespace" : "http://www.jsound.org/schemaschema",
  "$types" : [
    {
      "$kind" : "object",
      "$name" : "schema",
      "content" : {
        "$$namespace" : { "$type" : "string", "$optional" : false },
        "$$about" : { "$type" : "string", "$optional" : false },
        "$$imports" : {
          "$type" : {
            "$kind" : "array",
            "$content" : [
              {
                "$kind" : "object",
                "$content" : {
                  "$$namespace" : { "$type" : "string", "$optional" : false },
                  "$$location" : { "$type" : "string", "$optional" : false },
                  "$$prefix" : { "$type" : "string", "$optional" : false }
                }
              }
            ]
        },
        "$$types" : {
          "$type" : {
            "$kind" : "array",
            "$content" : [
              {
                "$kind" : "union",
                "$content" : [ "atomic-type", "object-type", "array-type", "union-type" ]
              }
            ]
          }
        }
      }
    }
    {
      "$kind" : "object",
      "$name" : "atomic-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "atomic" ]
          }
        },
        "$$name" :             { "$type" : "qualified-name", "$optional" : true },
        "$$baseType" :         { "$type" : "qualified-name" }
        "$$pattern" :          { "$type" : "string", "$optional" : true },
        "$$length" :           { "$type" : "integer","$optional" : true },
        "$$minLength" :        { "$type" : "integer","$optional" : true },
        "$$maxLength" :        { "$type" : "integer","$optional" : true },
        "$$totalDigits" :      { "$type" : "integer","$optional" : true },
        "$$fractionDigits" :   { "$type" : "integer","$optional" : true },
        "$$maxInclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$maxExclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$minExclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$minInclusive" :     { "$type" : "atomic", "$optional" : true },
        "$$explicitTimezone" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "required", "prohibited", "optional" ]
          },
          "$optional" : true
        },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" : [ "atomic" ] },
          "$optional" : true
        },
        "$$constraints" : {
          "$type" : { "$kind" : "array", "$content" : [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "object",
      "$name" : "object-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "object" ]
          }
        },
        "$$name" : { "$type" : "qualified-name", "$optional" : true },
        "$$content" : {
          "$type" : {
            "$kind" : "object",
            "$constraints" : [ "every $key in keys($$) satisfies $$.$key instance of pair-descriptor" ]
          }
          "$optional" : true
        },
        "$$open" : { "$type" : "boolean", $optional" : true },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" : [ "atomic" ] },
          "$optional" : true
        },
        "$$constraints" : {
          "$type" : { "$kind" : "array", "$content" : [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "object",
      "$name" : "pair-descriptor"
      "$content" : {
        "$$type" : { "$type" : "type-or-reference" },
        "$$optional" : { "$type" : "boolean", "$default" : "false" }
        "$$default" : { "$type" : "item", "$optional" : true }
      }
    },
    {
      "$kind" : "object",
      "$name" : "array-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "array" ]
          }
        },
        "$$name" : { "$type" : "qualified-name", "$optional" : true },
        "$$content" : {
          "$type" : {
            "$kind" : "array",
            "$content" : [ "type-or-reference" ],
            "$minLength" : 1,
            "$maxLength" : 1
          }
        },
        "$$minLength" : { "$type" : "integer", "$optional" : true },
        "$$maxLength" : { "$type" : "integer", "$optional" : true },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" : [ "atomic" ] },
          "$optional" : true
        },
        "$$constraints" : {
          "$type" : { "$kind" : "array", "$content" : [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "object",
      "$name" : "union-type",
      "$content" : {
        "$$kind" : {
          "$type" : {
            "$kind" : "atomic",
            "$baseType" : "string",
            "$enumeration" : [ "union" ]
          }
        },
        "$$name" : { "$type" : "qualified-name", "$optional" : true },
        "$$content" : { "$type" : { "$kind" : "array", "$content" : [ "type-or-reference" ] } },
        "$$enumeration" : {
          "$type" : { "$kind" : "array", $content" :  [ "atomic" ] },
          "$optional" : true },
        "$$constraints" : {
          "$type" : { "$kind" : "array", $content" :  [ "string" ] },
          "$optional" : true
        }
      }
    },
    {
      "$kind" : "atomic",
      "$name" : "qualified-name",
      "$baseType" : "string",
      "$pattern" : "([^:${}]+:|Q{[^${}]+})?[^:${}]+"
    },
    {
      "$kind" : "union",
      "$name" : "type-or-reference",
      "$content" : [ "qualified-name", "atomic-type", "object-type", "array-type", "union-type" ]
    }
  ]
}
</pre></div><div class="appendix"><div class="titlepage"><div><div><h1 class="title"><a id="appe-JSound-Revision_History"></a>Revision History</h1></div></div></div><div class="para"><p></p>
		<div class="revhistory"><table summary="Revision History"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 1-4</td><td align="left">Thu Nov 21, 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Added static (Compilation/Schema soundness) and dynamic (annotation) errors.</td></tr><tr><td>Forced a Derived Type's facets to always be more restrictive that its Base Type's.</td></tr><tr><td>Cleaned up a redundancy between Validation and Annotation phases. The Validation Phase does not raise a dynamic error, but simply returns false if validation fails. The intent is that the Annotation phase can then be used to get information about the validation issues.</td></tr><tr><td>In case of an error, the Annotation phase also provides a $reason field in the error value. The intent is to specify against which Facet validation failed.</td></tr><tr><td>Object and array subtyping is now allowed.</td></tr><tr><td>Added the type against which Schema Documents are valid in the Schema of Schemas.</td></tr></table>

				</td></tr><tr><td align="left">Revision 1-3</td><td align="left">Mon Jun 3, 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Added constraints on $content and $open for objects, to ensure proper object-oriented inheritance. But for the moment, object derivation is limited to the topmost type, so that these constraints are trivially fulfilled.</td></tr><tr><td>Fixed typos.</td></tr><tr><td>Cleaned up Schema Schema.</td></tr></table>

				</td></tr><tr><td align="left">Revision 1-2</td><td align="left">Thu May 30 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>Annotating an atomic means casting it.</td></tr><tr><td>The lexical space of date/dateTime/time was extended to support RFC 2822.</td></tr><tr><td>Local types have no prefix.</td></tr><tr><td>The URI Qualified Name syntax may also be used to reference types.</td></tr><tr><td>$optional is ignored if a $default is provided for a pair.</td></tr><tr><td>Added $about field to Schema and Types for free content.</td></tr><tr><td>The Input of the Validation and Annotation processes is now a JDM instance (typically freshly parsed).</td></tr><tr><td>$layout and $member-types were renamed to $content</td></tr><tr><td>The special key $any was removed from object $content. JSONiq constraints can be used instead.</td></tr><tr><td>Default values can be computed with a JSONiq query.</td></tr></table>

				</td></tr><tr><td align="left">Revision 1-2</td><td align="left">Wed May 29 2013</td><td align="left"><span class="author"><span class="firstname">Ghislain</span> <span class="surname">Fourny</span></span></td></tr><tr><td align="left" colspan="3">
					<table border="0" summary="Simple list" class="simplelist"><tr><td>First Working Draft.</td></tr></table>

				</td></tr></table></div>

	</div></div><div class="index"><div class="titlepage"><div><div><h1 class="title"><a id="idm139773372063072"></a>Index</h1></div></div></div><div class="index"></div></div></div></body></html>